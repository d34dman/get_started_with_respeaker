{
    "docs": [
        {
            "location": "/", 
            "text": "Getting Started with ReSpeaker\n\n\nReSpeaker is an open modular voice interface to hack things around you. Let you interact with your home appliances, your plant, your office, your internet-equipped devices or any other things in your daily life, all by your voice.", 
            "title": "Home"
        }, 
        {
            "location": "/#getting-started-with-respeaker", 
            "text": "ReSpeaker is an open modular voice interface to hack things around you. Let you interact with your home appliances, your plant, your office, your internet-equipped devices or any other things in your daily life, all by your voice.", 
            "title": "Getting Started with ReSpeaker"
        }, 
        {
            "location": "/Introduction/", 
            "text": "Hardware\n\n\nReSpeaker Core\n\n\n\n\nKey Features\n\n\n\n\nTechnology Specs\n\n\n\n\n\n\nAI7688 Wi-Fi Module:\n\n\nOperation system: GNU/Linux based OpenWrt\n\n\nWi-Fi Network: Support Legacy 802.11b/g and HT 802.11n modes\n\n\nExpansion: Two expansion headers for I2C, GPIO and USB 2.0 host\n\n\nInterfaces: Built-in 3.5mm AUX port, Micro USB and SD card slot\n\n\nATMega32U4 Coprocessor:\n\n\nUSB CDC virtual serial port for linux console\n\n\n12 programmable RGB LED indicators\n\n\n8 on board touch sensors\n\n\nCodec WM8960:\n\n\nDAC SNR 98dB (\u2018A\u2019 weighted), THD -84dB at 48kHz, 3.3V  \n\n\nADC SNR 94dB (\u2018A\u2019 weighted), THD -82dB at 48kHz, 3.3V  \n\n\nStereo Class D Speaker Driver with 87% efficiency (1W output)  \n\n\nOn-chip Headphone Driver  \n\n\n40mW output power into 16\u03a9 at 3.3V  \n\n\nTHD -75dB at 20mW, SNR 90dB with 16\u03a9 load  \n\n\nOn-chip PLL provides flexible clocking scheme  \n\n\nSample rates: 8, 11.025, 12, 16, 22.05, 24, 32, 44.1, 48 kHz\n\n\nPower Supply: 5V DC  \n\n\nDimensions: 70mm diameter  \n\n\nWeight: 17g \n\n\n\n\nPin-out Diagram\n\n\n\n\n\n\n\n\nGPIO0/I2S_ADC: Drive external encoder/decoder, ADC signal\n\n\n\n\n\n\nGPIO1/I2S_DAC: Drive external encoder/decoder, DAC signal\n\n\n\n\n\n\nGPIO2/I2S_LRCLK: Drive external encoder/decoder, Left/right channel sample clock \n\n\n\n\n\n\nGPIO3/I2S_BCLK: Drive external encoder/decoder, Bit clock\n\n\n\n\n\n\nMCLK_OUT: Master clock for external device\n\n\n\n\n\n\nHP_SEL: Headphone channel select. If use ReSpeaker Mic Array to output audio, set HP_SEL high\n\n\n\n\n\n\nHP_L: Analog audio left channel from ReSpeaker Mic Array\n\n\n\n\n\n\nHP_R: Analog audio right channel from ReSpeaker Mic Array\n\n\n\n\n\n\nAGND: Analog ground for audio\n\n\n\n\n\n\nResources\n\n\n\n\nReSpeaker Core v1.0 SCH\n\n\nReSpeaker Core v1.0 BRD\n\n\nReSpeaker Core v1.0 Schematic(pdf)\n\n\nReSpeaker Core v1.0 PCB bottom(pdf)\n\n\nReSpeaker Core v1.0 PCB top(pdf)\n\n\nReSpeaker Pro Case 3D\n\n\n\n\nReSpeaker Mic Array\n\n\nDescription\n\n\nThe ReSpeaker Mic Array can be stacked (connected) right onto the top of ReSpeaker Core to significantly improve the voice interaction experience. It is developed based on the XVSM-2000 Smart Microphone from XMOS. The board integrates 7 PDM microphones to help enhance ReSpeaker's acoustic DSP performance to a much higher level.\n\n\n\n\nKey Features\n\n\n\n\nFar-field Voice Capture\n\n\nAcoustic Source Localization\n\n\nBeamforming\n\n\nNoise Suppression\n\n\nDe-reverberation\n\n\n\n\nTechnology Specs\n\n\n\n\n\n\nXVSM-2000 with 16 cores inside:\n\n\n16 real-time logical cores on 2 xCore tiles.\n\n\nCores share up to 2000 MIPS in dual issue mode.\n\n\n512KB internal single-cycle SRAM and 2MB built-in flash. \n\n\n16KB internal OTP (max 8KB per tile),\n\n\nUSB PHY, fully compliant with USB 2.0 specification.\n\n\nProgrammable I/O.\n\n\nSupply DFU Mode.\n\n\n7 Digital Microphones: \n\n\nfar field voice recognition or sound localization usefulness.\n\n\nST MP34DT01-M.\n\n\n-26 dBFS sensitivity.\n\n\n120 dBSPL acoustic overload point.\n\n\n61 dB signal-to-noise ratio.\n\n\nOmnidirectional sensitivity.\n\n\nPDM output.\n\n\n12 RGB LEDs: \n\n\n256 levels brightness.\n\n\n800kHz line data transmission.\n\n\nAudio output: \n\n\nOn board 3.5mm Aux output.\n\n\nWOLFSON WM8960.\n\n\n24 or 16bit 16kHz stereo output.\n\n\n40 mW output Power into 16 \u2126 @ 3.3 V.\n\n\nClock Sync\uff1a\n\n\nOn board PLL.\n\n\nProgrammable sample clock for DAC,MIC.\n    (Disable if DSP is used in XVSM-2000).\n\n\nPower supply: \n\n\n5V supply from Micro USB or expansion header. \n\n\nSize: \n\n\nDiameter 70mm.\n\n\nWeight: \n\n\n15.25g\n\n\n\n\nResources\n\n\n\n\nReSpeaker Microphone Array SCH\nPCB\n\n\n\n\nReSpeaker Grove Extension Board\n\n\nDescription\n\n\nThe Grove extension board can be stacked (connected) right onto the top of ReSpeaker. It brings even more possibilities as you can connect various Grove sensors and actuators to extend ReSpeaker\u2019s capabilities. The board provides up to 10 Grove ports for interfacing with a range of plug-n-play Grove sensors and actuators.\n\n\n\n\nKey Features\n\n\n\n\n\n\nUp to 10 Grove Ports\n\n\n\n\n\n\nStackable with ReSpeaker Core and ReSpeaker Mic Array\n\n\n\n\n\n\nTechnology Specs\n\n\n\n\n\n\nGrove Ports: 10\n\n\nDigital I/Os: 3\n\n\nAnalog I/Os: 4\n\n\nI2C Interface: 2\n\n\nUART: 1\n\n\nDimensions: 70mm (Diameter)\n\n\nWeight: 15.25g\n\n\n\n\nSoftware\n\n\nOpenWrt\n\n\n\n\nReSpeaker runs a open-source distribution of embedded Linux called \nOpenWrt\n on AI7688 Wi-Fi Module. \n\n\nWhen Voice Interaction, onbroad pixel leds and touch sensors, kinds of \nGrove sensors and actuators\n and powerful network capabilities all focus on a Linux system which has small volume, low power consumption and enough computing capacity, ReSpeaker may become a perfect carrier of your IoT or artificial intelligence applications. That is why we create ReSpeaker.\n\n\nArduino\n\n\n\n\nThe ATMega32U4 Coprocessor on ReSpeaker is programmed using the \nArduino Software(IDE) 1.6.8+\n and our \nReSpeaker Arduino Library\n. \n\n\nArduino is an open-source electronics platform based on easy-to-use hardware and software. With Arduino on ReSpeaker, developers are able to make creative applications in their familiar area.", 
            "title": "Introduction"
        }, 
        {
            "location": "/Introduction/#hardware", 
            "text": "", 
            "title": "Hardware"
        }, 
        {
            "location": "/Introduction/#respeaker-core", 
            "text": "", 
            "title": "ReSpeaker Core"
        }, 
        {
            "location": "/Introduction/#key-features", 
            "text": "", 
            "title": "Key Features"
        }, 
        {
            "location": "/Introduction/#technology-specs", 
            "text": "AI7688 Wi-Fi Module:  Operation system: GNU/Linux based OpenWrt  Wi-Fi Network: Support Legacy 802.11b/g and HT 802.11n modes  Expansion: Two expansion headers for I2C, GPIO and USB 2.0 host  Interfaces: Built-in 3.5mm AUX port, Micro USB and SD card slot  ATMega32U4 Coprocessor:  USB CDC virtual serial port for linux console  12 programmable RGB LED indicators  8 on board touch sensors  Codec WM8960:  DAC SNR 98dB (\u2018A\u2019 weighted), THD -84dB at 48kHz, 3.3V    ADC SNR 94dB (\u2018A\u2019 weighted), THD -82dB at 48kHz, 3.3V    Stereo Class D Speaker Driver with 87% efficiency (1W output)    On-chip Headphone Driver    40mW output power into 16\u03a9 at 3.3V    THD -75dB at 20mW, SNR 90dB with 16\u03a9 load    On-chip PLL provides flexible clocking scheme    Sample rates: 8, 11.025, 12, 16, 22.05, 24, 32, 44.1, 48 kHz  Power Supply: 5V DC    Dimensions: 70mm diameter    Weight: 17g", 
            "title": "Technology Specs"
        }, 
        {
            "location": "/Introduction/#pin-out-diagram", 
            "text": "GPIO0/I2S_ADC: Drive external encoder/decoder, ADC signal    GPIO1/I2S_DAC: Drive external encoder/decoder, DAC signal    GPIO2/I2S_LRCLK: Drive external encoder/decoder, Left/right channel sample clock     GPIO3/I2S_BCLK: Drive external encoder/decoder, Bit clock    MCLK_OUT: Master clock for external device    HP_SEL: Headphone channel select. If use ReSpeaker Mic Array to output audio, set HP_SEL high    HP_L: Analog audio left channel from ReSpeaker Mic Array    HP_R: Analog audio right channel from ReSpeaker Mic Array    AGND: Analog ground for audio", 
            "title": "Pin-out Diagram"
        }, 
        {
            "location": "/Introduction/#resources", 
            "text": "ReSpeaker Core v1.0 SCH  ReSpeaker Core v1.0 BRD  ReSpeaker Core v1.0 Schematic(pdf)  ReSpeaker Core v1.0 PCB bottom(pdf)  ReSpeaker Core v1.0 PCB top(pdf)  ReSpeaker Pro Case 3D", 
            "title": "Resources"
        }, 
        {
            "location": "/Introduction/#respeaker-mic-array", 
            "text": "", 
            "title": "ReSpeaker Mic Array"
        }, 
        {
            "location": "/Introduction/#description", 
            "text": "The ReSpeaker Mic Array can be stacked (connected) right onto the top of ReSpeaker Core to significantly improve the voice interaction experience. It is developed based on the XVSM-2000 Smart Microphone from XMOS. The board integrates 7 PDM microphones to help enhance ReSpeaker's acoustic DSP performance to a much higher level.", 
            "title": "Description"
        }, 
        {
            "location": "/Introduction/#key-features_1", 
            "text": "Far-field Voice Capture  Acoustic Source Localization  Beamforming  Noise Suppression  De-reverberation", 
            "title": "Key Features"
        }, 
        {
            "location": "/Introduction/#technology-specs_1", 
            "text": "XVSM-2000 with 16 cores inside:  16 real-time logical cores on 2 xCore tiles.  Cores share up to 2000 MIPS in dual issue mode.  512KB internal single-cycle SRAM and 2MB built-in flash.   16KB internal OTP (max 8KB per tile),  USB PHY, fully compliant with USB 2.0 specification.  Programmable I/O.  Supply DFU Mode.  7 Digital Microphones:   far field voice recognition or sound localization usefulness.  ST MP34DT01-M.  -26 dBFS sensitivity.  120 dBSPL acoustic overload point.  61 dB signal-to-noise ratio.  Omnidirectional sensitivity.  PDM output.  12 RGB LEDs:   256 levels brightness.  800kHz line data transmission.  Audio output:   On board 3.5mm Aux output.  WOLFSON WM8960.  24 or 16bit 16kHz stereo output.  40 mW output Power into 16 \u2126 @ 3.3 V.  Clock Sync\uff1a  On board PLL.  Programmable sample clock for DAC,MIC.\n    (Disable if DSP is used in XVSM-2000).  Power supply:   5V supply from Micro USB or expansion header.   Size:   Diameter 70mm.  Weight:   15.25g", 
            "title": "Technology Specs"
        }, 
        {
            "location": "/Introduction/#resources_1", 
            "text": "ReSpeaker Microphone Array SCH PCB", 
            "title": "Resources"
        }, 
        {
            "location": "/Introduction/#respeaker-grove-extension-board", 
            "text": "", 
            "title": "ReSpeaker Grove Extension Board"
        }, 
        {
            "location": "/Introduction/#description_1", 
            "text": "The Grove extension board can be stacked (connected) right onto the top of ReSpeaker. It brings even more possibilities as you can connect various Grove sensors and actuators to extend ReSpeaker\u2019s capabilities. The board provides up to 10 Grove ports for interfacing with a range of plug-n-play Grove sensors and actuators.", 
            "title": "Description"
        }, 
        {
            "location": "/Introduction/#key-features_2", 
            "text": "Up to 10 Grove Ports    Stackable with ReSpeaker Core and ReSpeaker Mic Array", 
            "title": "Key Features"
        }, 
        {
            "location": "/Introduction/#technology-specs_2", 
            "text": "Grove Ports: 10  Digital I/Os: 3  Analog I/Os: 4  I2C Interface: 2  UART: 1  Dimensions: 70mm (Diameter)  Weight: 15.25g", 
            "title": "Technology Specs"
        }, 
        {
            "location": "/Introduction/#software", 
            "text": "", 
            "title": "Software"
        }, 
        {
            "location": "/Introduction/#openwrt", 
            "text": "ReSpeaker runs a open-source distribution of embedded Linux called  OpenWrt  on AI7688 Wi-Fi Module.   When Voice Interaction, onbroad pixel leds and touch sensors, kinds of  Grove sensors and actuators  and powerful network capabilities all focus on a Linux system which has small volume, low power consumption and enough computing capacity, ReSpeaker may become a perfect carrier of your IoT or artificial intelligence applications. That is why we create ReSpeaker.", 
            "title": "OpenWrt"
        }, 
        {
            "location": "/Introduction/#arduino", 
            "text": "The ATMega32U4 Coprocessor on ReSpeaker is programmed using the  Arduino Software(IDE) 1.6.8+  and our  ReSpeaker Arduino Library .   Arduino is an open-source electronics platform based on easy-to-use hardware and software. With Arduino on ReSpeaker, developers are able to make creative applications in their familiar area.", 
            "title": "Arduino"
        }, 
        {
            "location": "/QuickStart/", 
            "text": "Quick Start\n\n\nSetup Wi-Fi\n\n\nReSpeaker is set to Repeater Mode as default, and you have to connect it to an existing wireless network before enjoying the speech recognition with the Internet.\n\n\nWhen you first power on ReSpeaker, it will create a Wi-Fi network called \"ReSpeakerXXXXXX\". Here \"XXXXXX\" is the last 6 of your ReSpeaker MAC address, which is marked on the board. Connect your computer to this network. \n\n\n\n\n\n\n\n\n\nIf \"ReSpeakerXXXXXX\" does not appear, but \"LinkIt_Smart_7688_XXXXXX\" is found. Please click \nhere\n.\n\n\nOnce you've obtained an IP address, open a web browser, and enter \n192.168.100.1\n in the address bar. After a few seconds, a web page will appear asking for ssid and password of an existing Wi-Fi network.\n\n\n\n\n\n\n\n\n\nSelect the Wi-Fi you wish to connect to and enter the password. When you press the \nOK\n button, ReSpeaker will join the specified network.\n\n\nNow your ReSpeaker is able to visit the Internet.\n\n\nAlso, here are some ways to setup Wi-Fi with command line. \nClick here!\n\n\nDashboard\n\n\n\n\n\n\n\n\n\nVisit \n192.168.100.1\n again, the Dashboard of ReSpeaker will appear. You are able to have a overview of ReSpeaker, set up network, wifi and system on Dashboard.\n\n\nSystem Update\n\n\nTo update the firmware of you ReSpeaker, enter \nhttp://192.168.100.1/home.html\n in a web browser and click \nSystem Update\n. \n\n\n\n\n\n\n\n\n\nThen ReSpeaker will check its version and the following web page will appear when there is an new firmware for ReSpeaker. Click \"UPDATE\" to continue and click \"UPDATE NOW\" after finish download. It will cost about 5 minutes for ReSpeaker to install the firmware and reboot, please \ndon't turn off\n ReSpeaker when updating.\n\n\n\n\n\n\n\n\n\nUpdate for old version\n\n\nNote:\n If you can not update your ReSpeaker via Web or can not visit \nhttp://192.168.100.1/home.html\n, please click \nhere\n to download the lastest firmware on your computer, copy it to a SD card and plug the SD card into ReSpeaker. \n\n\nConnect to the \nserial console\n of ReSpeaker, type the following command lines to update the firmware:\n\n\nmount /dev/mmcblk0p1 /mnt\ncd /mnt\nsysupgrade -n -F ramips-openwrt-latest-LinkIt7688-squashfs-sysupgrade.bin\n\n\n\n\nIt will cost about 3 minutes for ReSpeaker to install the firmware and reboot, please \ndon't turn off\n ReSpeaker when updating.\n\n\n\n\n\n\n\n\n\nMopidy music player\n\n\nMopidy is an extensible music server written in Python. \nReSpeaker\n runs Mopidy server for playing music from local disk, Spotify, SoundCloud, Google Play Music and more.\n\n\nAfter connecting your computer to ReSpeaker's Wi-Fi, enter \nhttp://192.168.100.1/home.html\n in a web browser.\nThen Mopidy web page will appear.\n\n\n\n\n\n\n\n\n\nPlease click \nMusic Player\n to enter the HTML frontend for the Mopidy music server. Now you are able to play music on ReSpeaker from local disk and radio streams!\n\n\n\n\n\n\n\n\n\nFile manager\n\n\nFile manager is an extension of Mopidy music server. It allows you to browse/search/edit/upload your local file system. Enter \nhttp://192.168.100.1/home.html\n in a web browser and click \nFile Manager\n to get started.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeb terminal\n\n\nWeb terminal \nPyxterm\n, a pure python websocket terminal server,  is also an extension of Mopidy music server to get the web terminal. Enter \nhttp://192.168.100.1/home.html\n in a web browser and click \nWeb Terminal\n to login in ReSpeaker terminal. \nThe default username and password are all \"root\".\n\n\n\n\n\n\n\n\n\nSerial console\n\n\n\n\nBaudrate: 57600\n\n\nTerminal app - on Windows, \nputty\n is recommended. On Linux/Mac, use \nscreen /dev/xxx 57600\n\n\n\n\nFirst impression with Voice Interaction - ReSpeaker, play music!\n\n\nWith Bing Speech API, ReSpeaker can turn on and recognize audio coming from the microphone in real-time, or recognize audio from a file. \n\n\nTo use Bing Speech API, first you have to get a key of Microsoft Cognitive Services from \nhere\n, and copy it to \nBING_KEY = ''\n, then save the following code in \nplaymusic.py\n and run it \npython playmusic.py\n\n\n\n\n\n\n\n\n\nimport logging\nimport time\nimport os\nfrom threading import Thread, Event\nfrom respeaker import Microphone\nfrom respeaker.bing_speech_api import BingSpeechAPI\n\n# use madplay to play mp3 file     \nos.system('madplay')               \n\n# get a key from https://www.microsoft.com/cognitive-services/en-us/speech-api\nBING_KEY = ''      \n\n\ndef task(quit_event):                                                         \n    mic = Microphone(quit_event=quit_event)                                   \n    bing = BingSpeechAPI(key=BING_KEY)                                        \n\n    while not quit_event.is_set():\n        if mic.wakeup('respeaker'):        \n            print('Wake up')               \n            data = mic.listen()            \n            try:                      \n                text = bing.recognize(data)\n                if text:           \n                    print('Recognized %s' % text)\n                    if 'play music' in text:\n                        print('I will play music!')\n                        os.system('madplay Tchaikovsky_Concerto_No.1p.mp3')\n            except Exception as e:               \n                print(e.message)                 \n\ndef main():                                                              \n    logging.basicConfig(level=logging.DEBUG)                                                           \n    quit_event = Event()        \n    thread = Thread(target=task, args=(quit_event,))\n    thread.start()                          \n    while True:                             \n        try:                                \n            time.sleep(1)                           \n        except KeyboardInterrupt:                   \n            print('Quit')                           \n            quit_event.set()\n            break        \n    thread.join()                \n\nif __name__ == '__main__':       \n    main()                  \n\n\n\n\nTry to say \"ReSpeaker, play music!\". Then ReSpeaker will play \"Tchaikovsky_Concerto_No.1p.mp3\" in the current path with \nmadplay\n.\n\n\n\n\n\n\n\n\n\nPlay with AirPlay\nDLNA\n\n\n\n\nWith Airplay\nDLNA, you can stream music to ReSpeaker. \n\n\n\n\nUse Airplay\n\n\n\n\nConnect to the same Wi-Fi network on your iOS device and ReSpeaker.\n\n\nOn your iOS device, swipe up from the bottom of your screen to open Control Center.\n\n\nIn Control Center, swipe horizontally to find the Now Playing screen.\n\n\n\n\nSelect ReSpeaker as the following picture:\n\n\n\n\n\n\n\n\n\n\n\n\nConnect your headphone/speaker to respeaker, then you can enjoy the music now. \n\n\n\n\n\n\nUse DLNA\n\n\n\n\nConnect your smart phone to \nReSpeaker's Wi-Fi\n.\n\n\nOn your smart phone, open a DLNA software, such as: \nAllConnect\n.\n\n\n\n\nSelect ReSpeaker as the following picture:\n\n\n\n\n\n\n\n\n\n\n\n\nConnect your headphone/speaker to respeaker, then you can enjoy the music now. \n\n\n\n\n\n\nUse SD Card to Extend Storage\n\n\nMore often than not, a limited amount of storage is available on embedded devices(ReSpeaker has only 5M on-board flash storage left for users). More storage for applications and data can expand ReSpeaker's potential, so use SD card to extend storage as an \nextroot\n is a good choice.\n\n\nBy employing \nextroot\n, expansion of the storage capacity of your root file system is accomplished by using an added storage device. \nDuring the boot process, external storage space is mounted as the root file system, or in an overlay configuration over the original file system. \n\n\n\n\n\n\nMake sure your SD card is plugged into ReSpeaker and \n/dev/mmcblk0p1\n can be detected by \ndf -h\n or \nls /dev\n.\n\n\nroot@ReSpeaker:/# df -h\nFilesystem                Size      Used Available Use% Mounted on\nrootfs                    1.8M    832.0K    960.0K  46% /\n/dev/root                29.0M     29.0M         0 100% /rom\ntmpfs                    61.7M    276.0K     61.5M   0% /tmp\n/dev/mtdblock6            1.8M    832.0K    960.0K  46% /overlay\noverlayfs:/overlay        1.8M    832.0K    960.0K  46% /\ntmpfs                   512.0K         0    512.0K   0% /dev\n/dev/mmcblk0p1            7.4G      2.5M      7.4G   0% /tmp/run/mountd/mmcblk0p1\n\n\n\n\n\n\nFormat your SD card into two partitions, one is FAT32, the other is EXT4. EXT4 file system will be as an extroot while FAT32 will be as a normal storage device, which is able to transfer files between ReSpeaker and your PC.\n\n\n```\numount /dev/mmcblk0p1\nfdisk /dev/mmcblk0\n\n\n------------------ fdisk ------------------------\n\n\n\n\nCommand (m for help):o\nCreated a new DOS disklabel\nCommand (m for help):n\nPartition type\np   primary (0 primary, 0 extended, 4 free)\ne   extended (container for logical partitions)\nSelect (default p):p\nPartition number (1-4, default 1):1\nFirst sector (2048-15523839, default 2048):\nLast sector, +sectors or +size{K,M,G,T,P} (2048-15523839, default 15523839): +2G\nCommand (m for help):n\nPartition type\np   primary (1 primary, 0 extended, 3 free)\ne   extended (container for logical partitions)\nSelect (default p):p\nPartition number (1-4, default 2):2\nFirst sector (4196352-15523839, default 4196352):\nLast sector, +sectors or +size{K,M,G,T,P} (4196352-15523839, default 15523839): \nCommand (m for help):w\nThe partition table has been altered.\nCalling i[  292.010000]  mmcblk0: p1 p2\noctl() to re-read partition table.\nSyncing disks.\n\n\n\n\n------------------ end ------------------------\n\n\nmkfs.fat /dev/mmcblk0p1\nmkfs.ext4 /dev/mmcblk0p2\n\n\nreload mtk_sd kernel module\n\n\nrmmod mtk_sd\ninsmod mtk_sd\n```\n\n\n\n\n\n\nPrepare your external storage root overlay.\n\n\nmount /dev/mmcblk0p2 /mnt ; tar -C /overlay -cvf - . | tar -C /mnt -xf - ; umount /mnt\n\n\n\n\n\n\nCreate fstab with the following command. This command will create a fstab template enabling all partitions and setting '/mnt/mmcblk0p2' partition as '/overlay' partition.\n\n\nblock detect \n /etc/config/fstab;\nsed -i s/option$'\\t'enabled$'\\t'\\'0\\'/option$'\\t'enabled$'\\t'\\'1\\'/ /etc/config/fstab;\nsed -i s#/mnt/mmcblk0p2#/overlay# /etc/config/fstab;\ncat /etc/config/fstab;\n\n\n\n\n\n\nCheck if it is mountable to overlay.\n\n\nroot@mylinkit:/# mount /dev/mmcblk0p2 /overlay/\nroot@ReSpeaker:/# df -h\nFilesystem                Size      Used Available Use% Mounted on\nrootfs                    1.8M    832.0K    960.0K  46% /\n/dev/root                29.0M     29.0M         0 100% /rom\ntmpfs                    61.7M    276.0K     61.5M   0% /tmp\n/dev/mtdblock6            5.2G     11.8M      4.9G   0% /overlay\noverlayfs:/overlay        1.8M    832.0K    960.0K  46% /\ntmpfs                   512.0K         0    512.0K   0% /dev\n/dev/mmcblk0p2            5.2G     11.8M      4.9G   0% /tmp/run/mountd/mmcblk0p2\n/dev/mmcblk0p1            2.0G      4.0K      2.0G   0% /tmp/run/mountd/mmcblk0p1\n/dev/mmcblk0p2            5.2G     11.8M      4.9G   0% /overlay\n\n\n\n\n\n\nReboot ReSpeaker and check again. If SD card is mounted automatically, you are done. More informations about \nextroot\n, please click \nhere\n.\n\n\n\n\n\n\nInstall software on ReSpeaker\n\n\nAfter extending storage with a SD card, there are enough storage to install software on ReSpeaker.\n\n\n\n\n\n\nInstall git\n\n\nopkg update\nopkg install git git-http", 
            "title": "Quick Start"
        }, 
        {
            "location": "/QuickStart/#quick-start", 
            "text": "", 
            "title": "Quick Start"
        }, 
        {
            "location": "/QuickStart/#setup-wi-fi", 
            "text": "ReSpeaker is set to Repeater Mode as default, and you have to connect it to an existing wireless network before enjoying the speech recognition with the Internet.  When you first power on ReSpeaker, it will create a Wi-Fi network called \"ReSpeakerXXXXXX\". Here \"XXXXXX\" is the last 6 of your ReSpeaker MAC address, which is marked on the board. Connect your computer to this network.      If \"ReSpeakerXXXXXX\" does not appear, but \"LinkIt_Smart_7688_XXXXXX\" is found. Please click  here .  Once you've obtained an IP address, open a web browser, and enter  192.168.100.1  in the address bar. After a few seconds, a web page will appear asking for ssid and password of an existing Wi-Fi network.     Select the Wi-Fi you wish to connect to and enter the password. When you press the  OK  button, ReSpeaker will join the specified network.  Now your ReSpeaker is able to visit the Internet.  Also, here are some ways to setup Wi-Fi with command line.  Click here!", 
            "title": "Setup Wi-Fi"
        }, 
        {
            "location": "/QuickStart/#dashboard", 
            "text": "Visit  192.168.100.1  again, the Dashboard of ReSpeaker will appear. You are able to have a overview of ReSpeaker, set up network, wifi and system on Dashboard.", 
            "title": "Dashboard"
        }, 
        {
            "location": "/QuickStart/#system-update", 
            "text": "To update the firmware of you ReSpeaker, enter  http://192.168.100.1/home.html  in a web browser and click  System Update .      Then ReSpeaker will check its version and the following web page will appear when there is an new firmware for ReSpeaker. Click \"UPDATE\" to continue and click \"UPDATE NOW\" after finish download. It will cost about 5 minutes for ReSpeaker to install the firmware and reboot, please  don't turn off  ReSpeaker when updating.", 
            "title": "System Update"
        }, 
        {
            "location": "/QuickStart/#update-for-old-version", 
            "text": "Note:  If you can not update your ReSpeaker via Web or can not visit  http://192.168.100.1/home.html , please click  here  to download the lastest firmware on your computer, copy it to a SD card and plug the SD card into ReSpeaker.   Connect to the  serial console  of ReSpeaker, type the following command lines to update the firmware:  mount /dev/mmcblk0p1 /mnt\ncd /mnt\nsysupgrade -n -F ramips-openwrt-latest-LinkIt7688-squashfs-sysupgrade.bin  It will cost about 3 minutes for ReSpeaker to install the firmware and reboot, please  don't turn off  ReSpeaker when updating.", 
            "title": "Update for old version"
        }, 
        {
            "location": "/QuickStart/#mopidy-music-player", 
            "text": "Mopidy is an extensible music server written in Python.  ReSpeaker  runs Mopidy server for playing music from local disk, Spotify, SoundCloud, Google Play Music and more.  After connecting your computer to ReSpeaker's Wi-Fi, enter  http://192.168.100.1/home.html  in a web browser.\nThen Mopidy web page will appear.     Please click  Music Player  to enter the HTML frontend for the Mopidy music server. Now you are able to play music on ReSpeaker from local disk and radio streams!", 
            "title": "Mopidy music player"
        }, 
        {
            "location": "/QuickStart/#file-manager", 
            "text": "File manager is an extension of Mopidy music server. It allows you to browse/search/edit/upload your local file system. Enter  http://192.168.100.1/home.html  in a web browser and click  File Manager  to get started.", 
            "title": "File manager"
        }, 
        {
            "location": "/QuickStart/#web-terminal", 
            "text": "Web terminal  Pyxterm , a pure python websocket terminal server,  is also an extension of Mopidy music server to get the web terminal. Enter  http://192.168.100.1/home.html  in a web browser and click  Web Terminal  to login in ReSpeaker terminal. \nThe default username and password are all \"root\".", 
            "title": "Web terminal"
        }, 
        {
            "location": "/QuickStart/#serial-console", 
            "text": "Baudrate: 57600  Terminal app - on Windows,  putty  is recommended. On Linux/Mac, use  screen /dev/xxx 57600", 
            "title": "Serial console"
        }, 
        {
            "location": "/QuickStart/#first-impression-with-voice-interaction-respeaker-play-music", 
            "text": "With Bing Speech API, ReSpeaker can turn on and recognize audio coming from the microphone in real-time, or recognize audio from a file.   To use Bing Speech API, first you have to get a key of Microsoft Cognitive Services from  here , and copy it to  BING_KEY = '' , then save the following code in  playmusic.py  and run it  python playmusic.py     import logging\nimport time\nimport os\nfrom threading import Thread, Event\nfrom respeaker import Microphone\nfrom respeaker.bing_speech_api import BingSpeechAPI\n\n# use madplay to play mp3 file     \nos.system('madplay')               \n\n# get a key from https://www.microsoft.com/cognitive-services/en-us/speech-api\nBING_KEY = ''      \n\n\ndef task(quit_event):                                                         \n    mic = Microphone(quit_event=quit_event)                                   \n    bing = BingSpeechAPI(key=BING_KEY)                                        \n\n    while not quit_event.is_set():\n        if mic.wakeup('respeaker'):        \n            print('Wake up')               \n            data = mic.listen()            \n            try:                      \n                text = bing.recognize(data)\n                if text:           \n                    print('Recognized %s' % text)\n                    if 'play music' in text:\n                        print('I will play music!')\n                        os.system('madplay Tchaikovsky_Concerto_No.1p.mp3')\n            except Exception as e:               \n                print(e.message)                 \n\ndef main():                                                              \n    logging.basicConfig(level=logging.DEBUG)                                                           \n    quit_event = Event()        \n    thread = Thread(target=task, args=(quit_event,))\n    thread.start()                          \n    while True:                             \n        try:                                \n            time.sleep(1)                           \n        except KeyboardInterrupt:                   \n            print('Quit')                           \n            quit_event.set()\n            break        \n    thread.join()                \n\nif __name__ == '__main__':       \n    main()                    Try to say \"ReSpeaker, play music!\". Then ReSpeaker will play \"Tchaikovsky_Concerto_No.1p.mp3\" in the current path with  madplay .", 
            "title": "First impression with Voice Interaction - ReSpeaker, play music!"
        }, 
        {
            "location": "/QuickStart/#play-with-airplaydlna", 
            "text": "With Airplay DLNA, you can stream music to ReSpeaker.", 
            "title": "Play with AirPlay&amp;DLNA"
        }, 
        {
            "location": "/QuickStart/#use-airplay", 
            "text": "Connect to the same Wi-Fi network on your iOS device and ReSpeaker.  On your iOS device, swipe up from the bottom of your screen to open Control Center.  In Control Center, swipe horizontally to find the Now Playing screen.   Select ReSpeaker as the following picture:       Connect your headphone/speaker to respeaker, then you can enjoy the music now.", 
            "title": "Use Airplay"
        }, 
        {
            "location": "/QuickStart/#use-dlna", 
            "text": "Connect your smart phone to  ReSpeaker's Wi-Fi .  On your smart phone, open a DLNA software, such as:  AllConnect .   Select ReSpeaker as the following picture:       Connect your headphone/speaker to respeaker, then you can enjoy the music now.", 
            "title": "Use DLNA"
        }, 
        {
            "location": "/QuickStart/#use-sd-card-to-extend-storage", 
            "text": "More often than not, a limited amount of storage is available on embedded devices(ReSpeaker has only 5M on-board flash storage left for users). More storage for applications and data can expand ReSpeaker's potential, so use SD card to extend storage as an  extroot  is a good choice.  By employing  extroot , expansion of the storage capacity of your root file system is accomplished by using an added storage device. \nDuring the boot process, external storage space is mounted as the root file system, or in an overlay configuration over the original file system.     Make sure your SD card is plugged into ReSpeaker and  /dev/mmcblk0p1  can be detected by  df -h  or  ls /dev .  root@ReSpeaker:/# df -h\nFilesystem                Size      Used Available Use% Mounted on\nrootfs                    1.8M    832.0K    960.0K  46% /\n/dev/root                29.0M     29.0M         0 100% /rom\ntmpfs                    61.7M    276.0K     61.5M   0% /tmp\n/dev/mtdblock6            1.8M    832.0K    960.0K  46% /overlay\noverlayfs:/overlay        1.8M    832.0K    960.0K  46% /\ntmpfs                   512.0K         0    512.0K   0% /dev\n/dev/mmcblk0p1            7.4G      2.5M      7.4G   0% /tmp/run/mountd/mmcblk0p1    Format your SD card into two partitions, one is FAT32, the other is EXT4. EXT4 file system will be as an extroot while FAT32 will be as a normal storage device, which is able to transfer files between ReSpeaker and your PC.  ```\numount /dev/mmcblk0p1\nfdisk /dev/mmcblk0", 
            "title": "Use SD Card to Extend Storage"
        }, 
        {
            "location": "/QuickStart/#-fdisk-", 
            "text": "Command (m for help):o\nCreated a new DOS disklabel\nCommand (m for help):n\nPartition type\np   primary (0 primary, 0 extended, 4 free)\ne   extended (container for logical partitions)\nSelect (default p):p\nPartition number (1-4, default 1):1\nFirst sector (2048-15523839, default 2048):\nLast sector, +sectors or +size{K,M,G,T,P} (2048-15523839, default 15523839): +2G\nCommand (m for help):n\nPartition type\np   primary (1 primary, 0 extended, 3 free)\ne   extended (container for logical partitions)\nSelect (default p):p\nPartition number (1-4, default 2):2\nFirst sector (4196352-15523839, default 4196352):\nLast sector, +sectors or +size{K,M,G,T,P} (4196352-15523839, default 15523839): \nCommand (m for help):w\nThe partition table has been altered.\nCalling i[  292.010000]  mmcblk0: p1 p2\noctl() to re-read partition table.\nSyncing disks.", 
            "title": "------------------ fdisk ------------------------"
        }, 
        {
            "location": "/QuickStart/#-end-", 
            "text": "mkfs.fat /dev/mmcblk0p1\nmkfs.ext4 /dev/mmcblk0p2", 
            "title": "------------------ end ------------------------"
        }, 
        {
            "location": "/QuickStart/#reload-mtk_sd-kernel-module", 
            "text": "rmmod mtk_sd\ninsmod mtk_sd\n```    Prepare your external storage root overlay.  mount /dev/mmcblk0p2 /mnt ; tar -C /overlay -cvf - . | tar -C /mnt -xf - ; umount /mnt    Create fstab with the following command. This command will create a fstab template enabling all partitions and setting '/mnt/mmcblk0p2' partition as '/overlay' partition.  block detect   /etc/config/fstab;\nsed -i s/option$'\\t'enabled$'\\t'\\'0\\'/option$'\\t'enabled$'\\t'\\'1\\'/ /etc/config/fstab;\nsed -i s#/mnt/mmcblk0p2#/overlay# /etc/config/fstab;\ncat /etc/config/fstab;    Check if it is mountable to overlay.  root@mylinkit:/# mount /dev/mmcblk0p2 /overlay/\nroot@ReSpeaker:/# df -h\nFilesystem                Size      Used Available Use% Mounted on\nrootfs                    1.8M    832.0K    960.0K  46% /\n/dev/root                29.0M     29.0M         0 100% /rom\ntmpfs                    61.7M    276.0K     61.5M   0% /tmp\n/dev/mtdblock6            5.2G     11.8M      4.9G   0% /overlay\noverlayfs:/overlay        1.8M    832.0K    960.0K  46% /\ntmpfs                   512.0K         0    512.0K   0% /dev\n/dev/mmcblk0p2            5.2G     11.8M      4.9G   0% /tmp/run/mountd/mmcblk0p2\n/dev/mmcblk0p1            2.0G      4.0K      2.0G   0% /tmp/run/mountd/mmcblk0p1\n/dev/mmcblk0p2            5.2G     11.8M      4.9G   0% /overlay    Reboot ReSpeaker and check again. If SD card is mounted automatically, you are done. More informations about  extroot , please click  here .", 
            "title": "reload mtk_sd kernel module"
        }, 
        {
            "location": "/QuickStart/#install-software-on-respeaker", 
            "text": "After extending storage with a SD card, there are enough storage to install software on ReSpeaker.    Install git  opkg update\nopkg install git git-http", 
            "title": "Install software on ReSpeaker"
        }, 
        {
            "location": "/ProgrammingGuide/", 
            "text": "Programming Guide\n\n\nThis programming guide is a series of tutorials designed to get you started with ReSpeaker. Starting from the basics, it describes how to make voice interaction, create audio output and program Arduino on ReSpeaker.\n\n\nReSpeaker runs the \nOpenWrt\n system on MT7688, and provided with on broad \nReSpeaker Python API\n, which makes it friendly and quickly for developers to build IoT applications. On Arduino side, ReSpeaker also provide easy-to-use \nReSpeaker Arduino Library\n.\n\n\nHow to write a simple voice interaction program\n\n\nWith Bing Speech API, ReSpeaker can turn on and recognize audio coming from the microphone in real-time, or recognize audio from a file. \n\n\nTo use Bing Speech API, first you have to get a key of Microsoft Cognitive Services from \nhere\n, and copy it to \nBING_KEY = ''\n, then save the following code in \nbing.py\n and run it \npython bing.py\n\n\n\n\n\n\n\n\n\nThe following code is an example of how to use Bing Speech API and Microphone on ReSpeaker. After waking up ReSpeaker by saying \"ReSpeaker\" to the board, the code will start to record your voice, translate it to text and display it.\n\n\nimport logging\nimport time\nfrom threading import Thread, Event\nfrom respeaker import Microphone\nfrom respeaker.bing_speech_api import BingSpeechAPI\n\n\n# get a key from https://www.microsoft.com/cognitive-services/en-us/speech-api\nBING_KEY = ''      \n\n\ndef task(quit_event):                                                         \n    mic = Microphone(quit_event=quit_event)                                   \n    bing = BingSpeechAPI(key=BING_KEY)                                        \n\n    while not quit_event.is_set():\n        if mic.wakeup('respeaker'):        \n            print('Wake up')               \n            data = mic.listen()            \n            try:                      \n                text = bing.recognize(data)\n                if text:           \n                    print('Recognized %s' % text)\n            except Exception as e:               \n                print(e.message)                 \n\ndef main():                                                              \n    logging.basicConfig(level=logging.DEBUG)                                                           \n    quit_event = Event()        \n    thread = Thread(target=task, args=(quit_event,))\n    thread.start()                          \n    while True:                             \n        try:                                \n            time.sleep(1)                           \n        except KeyboardInterrupt:                   \n            print('Quit')                           \n            quit_event.set()\n            break        \n    thread.join()                \n\nif __name__ == '__main__':       \n    main()                  \n\n\n\n\n\n\n\n\n\n\n\nPlay Arduino with light, touch, sound and Internet\n\n\nReSpeaker Arduino Library\n is a library for controlling WS2812 RGB LEDs, touch sensors, SeeedStudio Grove modules on Arduino (ATmega32U4) and building communication bridge between Arduino (ATmega32U4) and linux based OpenWrt (MT7688).\n\n\nFeatures\n\n\n\n\nSupported capacitive touch sensing\n\n\nImplemented WS2812 RGB LED driver\n\n\nBuilt USB to Serial bridge and SPI bridge between Arduino (ATmega32U4) and linux based OpenWrt (MT7688)\n\n\n\n\nRequirements\n\n\n\n\nArduino IDE 1.6.8+. Please use Arduino IDE 1.6.8+ which has some useful new features\n\n\n\n\nInstallation\n\n\n\n\nDownload \nzip file\n and extract it into Arduino's libraries directory.\n\n\nRename \nrespeaker_arduino_library-master\n to \nrespeaker\n\n\nSelect \nTools-\nBoard-\nArduino Leonardo\n \n\n\n\n\nGetting Started\n\n\n\n\nLight - chasing colors\n\n\n\n\n```C\n  #include \"respeaker.h\"\n\n\nuint8_t offset = 0;\n\n\nvoid setup() {\n    respeaker.begin();\n    respeaker.pixels().set_brightness(128);      // set brightness level (from 0 to 255)\n  }\n\n\nvoid loop() {\n    respeaker.pixels().rainbow(offset++);\n    delay(10);\n  }\n  ```\n\n\n\n\nTouch \n Sound - touch to play\n\n\n\n\n```C\n  #include \"respeaker.h\"\n\n\n// wav or mp3 files on SD card\n  const char *sound_map[] = {\"a1.wav\", \"b1.wav\", \"c1.wav\", \"d1.wav\", \"e1.wav\", \"f1.wav\", \"g1.wav\", \"c2.wav\"};\n\n\nvoid setup() {\n    respeaker.begin();\n    respeaker.attach_touch_handler(touch_event);  // add touch event handler\n  }\n  void loop() {}\n\n\n// id: 0 ~ 7 - touch sensor id; event: 1 - touch, 0 - release\n  void touch_event(uint8_t id, uint8_t event) {\n    if (event) {\n      respeaker.play(sound_map[id]);\n    }\n  }\n  ```\n\n\n\n\nConnect to IFTTT maker channel\n\n\n\n\n```C\n  #include \"respeaker.h\"\n\n\n#define IFTTT_MAKER_CHANNEL_KEY \"\"              // add the key of your ifttt maker channel\n  #define EVENT                   \"ping\"\n\n\nconst char *ifttt_ping = \"curl -X POST https://maker.ifttt.com/trigger/\" EVENT \"/with/key/\" IFTTT_MAKER_CHANNEL_KEY;\n\n\nvoid setup() {\n    respeaker.begin();\n    respeaker.attach_touch_handler(touch_event);  // add touch event handler\n  }\n  void loop() {}\n\n\n// id: 0 ~ 7 - touch sensor id; event: 1 - touch, 0 - release\n  void touch_event(uint8_t id, uint8_t event) {\n    if (event == 1 \n id == 0) {\n      respeaker.exec(ifttt_ping);\n    }\n  }\n  ```\n\n\nData exchange between Arduino and OpenWrt\n\n\nThere are 2 data exchange ways between Arduino and OpenWrt: UART and SPI bridge. \n\n\nSPI bridge\n\n\nWith SPI bridge, OpenWrt works as master and Arduino works as salve. \n\n\nOn Arduino side, the SPI data will be received in this SPI interrupt handler.\n\n\nvoid spi_event(uint8_t addr, uint8_t *data, uint8_t len)  {\n    //handle the data sent from MT7688\n}\n\n\n\n\n\n\nuint8_t addr\n - the address of SPI\n\n\nuint8_t *data\n - the received data, it is a character array\n\n\nuint8_t len\n - the length of the received data\n\n\n\n\nIn \nReSpeaker Arduino Library\n, we have an\n\nexample\n of SPI bridge:\n\n\nvoid spi_event(uint8_t addr, uint8_t *data, uint8_t len)\n{\n  if (0 == addr) {\n    if (0 == data[0]) {   // all off\n      color = 0x000000;\n      pixels_state = 0;\n    } else if (1 == data[0]) {  // specific color\n      color = Pixels::RGB(data[1], data[2], data[3]);\n      pixels_state = 0;\n    } else if (2 == data[0] || 7 == data[0]) {    // listening mode, all green\n      color = Pixels::RGB(0, 0x40, 0);\n      pixels_state = 0;\n    } else if (3 == data[0]) {    // waiting mode\n      pixels_state = 1;\n    }  else if (4 == data[0]) {   // speaking mode\n      pixels_state = 2;\n    } else if (5 == data[0]) {    // volume mode\n      pixels_state = 3;\n      volume = data[3];\n      volume_changed_time = 0;\n    }\n  } else if (0xA0 == addr) {       // spectrum data\n    pixels_state = -1;\n    for (int i = 0; i \n PIXELS_NUM; i++) {\n      // Serial.print(data[i]);\n      // Serial.print(' ');\n      pixels-\nset_color(i, change_brightness(b2r(i * 255 / (PIXELS_NUM - 1)), data[i]));\n      // pixels-\nset_color(i, change_brightness(b2r(data[i]), data[i]));\n    }\n    pixels-\nupdate();\n    // Serial.print(\n\\r\\n\n);\n  }\n}\n\n\n\n\nNote: Please stop mopidy service on OpenWrt before using SPI bridge\n\n\n/etc/init.d/mopidy stop\n\n\n\n\nOn OpenWrt side, there is a spi instantiation in \"respeaker\" package. Import it from \"respeaker\", and send data with  \nspi.write(self, data=None, address=None)\n method. \n\n\n def write(self, data=None, address=None):\n            if address is not None:\n                data = bytearray([0xA5, address \n 0xFF, len(data) \n 0xFF]) + data + bytearray([crc8(data)])\n                response = self._write(data)[3:-1]\n            else:\n                response = self._write(data)\n\n            return response\n\n\n\n\n\n\ndata\n - the data sent to Arduino, it should be a bytearray\n\n\naddress\n - the address of SPI\n\n\n\n\nfrom respeaker import spi\n//send data [1, 0, 0, 50] to Arduino, which will make the leds turn blue.\nspi.write(data = bytearray([1, 0, 0, 50]), address = 0x00)\n\n\n\n\nUART\n\n\nThere are 2 serial ports available in ATmage32U4: \"serial\" and \"serial1\". The \"serial\" is sumilated by the USB port shared with MT7688 and the \"serial1\" (on TXD1 and RXD1) is connected to MT7688 (on UART_RXD2 and UART_TXD2). They have been set their baudrate to 57600 bps in respeaker.begin().\n\n\nvoid ReSpeaker::begin(int touch, int pixels, int spi)\n{\n    Serial.begin(57600);\n    Serial1.begin(57600);\n    ......\n}\n\n\n\n\nReSpeaker Arduino Library\n provides 2 menthods to send Linux command to Openwrt Shell directly.\n\n\nvoid ReSpeaker::play(const char *name)\n{\n    Serial1.print(\nplay \n);\n    Serial1.print(name);\n    Serial1.print('\\n');\n}\n\n\n\n\nSend a play-music command to OpenWrt shell\n\n\n\n\nconst char *name\n - the absolute path or SD card path of your music file\n\n\n\n\nvoid ReSpeaker::exec(const char *cmd)\n{\n    Serial1.print(cmd);\n    Serial1.print('\\n');\n}\n\n\n\n\nSend a Linux shell command line to OpenWrt Shell\n\n\n\n\nconst char *cmd\n - Linux shell command line\n\n\n\n\nFruit piano\n\n\n\n\n\n\n\n\n\nRather than the on board MT7688 Wi-FI module which runs the Linux based OpenWrt, ReSpeaker is also powered by the ATmega32u4 chip and it\u2019s absolutely Arduino compatible, which means, we can use ReSpeaker as a powerful Arduino board and do many \u2018Arduino\u2019 things. It\u2019s for learning, it\u2019s for practicing, and it\u2019s for fun.\n\n\nFor example, you can program it with Arduino IDE to have a special DIY piano that is built on 8 cherry tomatoes connecting to the 8 touch sensors of ReSpeaker.\n\n\n\n\n\n\n\n\n\nGetting Started\n\n\n\n\ngit clone https://github.com/respeaker/piano.git\n  On ReSpeaker, download the repository \n\n\nDownload \nReSpeaker Arduino Library\n in your computer\n\n\nUpload \npiano.ino\n to ReSpeaker's Arduino Leonardo (ATmega32U4)\n\n\nRun \npython piano.py\n on ReSpeaker's serial console\n\n\n\n\nWeather Cloud\n\n\n\n\n\n\n\n\n\nWeather Cloud is an awesome project for ReSpeaker. This cool build turns a ReSpeaker into a Weather Cloud, which is able to show you the whether with vivid light and sounds.\n\n\nIn this project, Openwrt is in charge of getting realtime weather information from the Internet, making voice interaction and audio output, while Arduino is responsible for controlling the colorful RGB LEDs.\n\n\nGetting started\n\n\n\n\ngit clone https://github.com/jerryyip/WeatherCloud.git\n  on ReSpeaker, download the repository \n\n\nDownload \nReSpeaker Arduino Library\n in your computer\n\n\nUpload \npixels_pattern.ino\n in ReSpeaker Arduino  Library to ReSpeaker's Arduino \n\n\nGet OpenWeatherMap appid from \nhere\n and copy it to \nappID = \"\"\n in \nmain.py\n, don't forget to add your city in \ncity=\"\"\n\n\nStop mopidy service on OpenWrt before using SPI bridge\n\n/etc/init.d/mopidy stop\n\n\nRun \npython main.py\n and say \"ReSpeaker, what is the weather like?\" to ReSpeaker.\n\n\nFor more details about how to make a Weather Could, please click \nhere\n.", 
            "title": "Programming guide"
        }, 
        {
            "location": "/ProgrammingGuide/#programming-guide", 
            "text": "This programming guide is a series of tutorials designed to get you started with ReSpeaker. Starting from the basics, it describes how to make voice interaction, create audio output and program Arduino on ReSpeaker.  ReSpeaker runs the  OpenWrt  system on MT7688, and provided with on broad  ReSpeaker Python API , which makes it friendly and quickly for developers to build IoT applications. On Arduino side, ReSpeaker also provide easy-to-use  ReSpeaker Arduino Library .", 
            "title": "Programming Guide"
        }, 
        {
            "location": "/ProgrammingGuide/#how-to-write-a-simple-voice-interaction-program", 
            "text": "With Bing Speech API, ReSpeaker can turn on and recognize audio coming from the microphone in real-time, or recognize audio from a file.   To use Bing Speech API, first you have to get a key of Microsoft Cognitive Services from  here , and copy it to  BING_KEY = '' , then save the following code in  bing.py  and run it  python bing.py     The following code is an example of how to use Bing Speech API and Microphone on ReSpeaker. After waking up ReSpeaker by saying \"ReSpeaker\" to the board, the code will start to record your voice, translate it to text and display it.  import logging\nimport time\nfrom threading import Thread, Event\nfrom respeaker import Microphone\nfrom respeaker.bing_speech_api import BingSpeechAPI\n\n\n# get a key from https://www.microsoft.com/cognitive-services/en-us/speech-api\nBING_KEY = ''      \n\n\ndef task(quit_event):                                                         \n    mic = Microphone(quit_event=quit_event)                                   \n    bing = BingSpeechAPI(key=BING_KEY)                                        \n\n    while not quit_event.is_set():\n        if mic.wakeup('respeaker'):        \n            print('Wake up')               \n            data = mic.listen()            \n            try:                      \n                text = bing.recognize(data)\n                if text:           \n                    print('Recognized %s' % text)\n            except Exception as e:               \n                print(e.message)                 \n\ndef main():                                                              \n    logging.basicConfig(level=logging.DEBUG)                                                           \n    quit_event = Event()        \n    thread = Thread(target=task, args=(quit_event,))\n    thread.start()                          \n    while True:                             \n        try:                                \n            time.sleep(1)                           \n        except KeyboardInterrupt:                   \n            print('Quit')                           \n            quit_event.set()\n            break        \n    thread.join()                \n\nif __name__ == '__main__':       \n    main()", 
            "title": "How to write a simple voice interaction program"
        }, 
        {
            "location": "/ProgrammingGuide/#play-arduino-with-light-touch-sound-and-internet", 
            "text": "ReSpeaker Arduino Library  is a library for controlling WS2812 RGB LEDs, touch sensors, SeeedStudio Grove modules on Arduino (ATmega32U4) and building communication bridge between Arduino (ATmega32U4) and linux based OpenWrt (MT7688).", 
            "title": "Play Arduino with light, touch, sound and Internet"
        }, 
        {
            "location": "/ProgrammingGuide/#features", 
            "text": "Supported capacitive touch sensing  Implemented WS2812 RGB LED driver  Built USB to Serial bridge and SPI bridge between Arduino (ATmega32U4) and linux based OpenWrt (MT7688)", 
            "title": "Features"
        }, 
        {
            "location": "/ProgrammingGuide/#requirements", 
            "text": "Arduino IDE 1.6.8+. Please use Arduino IDE 1.6.8+ which has some useful new features", 
            "title": "Requirements"
        }, 
        {
            "location": "/ProgrammingGuide/#installation", 
            "text": "Download  zip file  and extract it into Arduino's libraries directory.  Rename  respeaker_arduino_library-master  to  respeaker  Select  Tools- Board- Arduino Leonardo", 
            "title": "Installation"
        }, 
        {
            "location": "/ProgrammingGuide/#getting-started", 
            "text": "Light - chasing colors   ```C\n  #include \"respeaker.h\"  uint8_t offset = 0;  void setup() {\n    respeaker.begin();\n    respeaker.pixels().set_brightness(128);      // set brightness level (from 0 to 255)\n  }  void loop() {\n    respeaker.pixels().rainbow(offset++);\n    delay(10);\n  }\n  ```   Touch   Sound - touch to play   ```C\n  #include \"respeaker.h\"  // wav or mp3 files on SD card\n  const char *sound_map[] = {\"a1.wav\", \"b1.wav\", \"c1.wav\", \"d1.wav\", \"e1.wav\", \"f1.wav\", \"g1.wav\", \"c2.wav\"};  void setup() {\n    respeaker.begin();\n    respeaker.attach_touch_handler(touch_event);  // add touch event handler\n  }\n  void loop() {}  // id: 0 ~ 7 - touch sensor id; event: 1 - touch, 0 - release\n  void touch_event(uint8_t id, uint8_t event) {\n    if (event) {\n      respeaker.play(sound_map[id]);\n    }\n  }\n  ```   Connect to IFTTT maker channel   ```C\n  #include \"respeaker.h\"  #define IFTTT_MAKER_CHANNEL_KEY \"\"              // add the key of your ifttt maker channel\n  #define EVENT                   \"ping\"  const char *ifttt_ping = \"curl -X POST https://maker.ifttt.com/trigger/\" EVENT \"/with/key/\" IFTTT_MAKER_CHANNEL_KEY;  void setup() {\n    respeaker.begin();\n    respeaker.attach_touch_handler(touch_event);  // add touch event handler\n  }\n  void loop() {}  // id: 0 ~ 7 - touch sensor id; event: 1 - touch, 0 - release\n  void touch_event(uint8_t id, uint8_t event) {\n    if (event == 1   id == 0) {\n      respeaker.exec(ifttt_ping);\n    }\n  }\n  ```", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ProgrammingGuide/#data-exchange-between-arduino-and-openwrt", 
            "text": "There are 2 data exchange ways between Arduino and OpenWrt: UART and SPI bridge.", 
            "title": "Data exchange between Arduino and OpenWrt"
        }, 
        {
            "location": "/ProgrammingGuide/#spi-bridge", 
            "text": "With SPI bridge, OpenWrt works as master and Arduino works as salve.   On Arduino side, the SPI data will be received in this SPI interrupt handler.  void spi_event(uint8_t addr, uint8_t *data, uint8_t len)  {\n    //handle the data sent from MT7688\n}   uint8_t addr  - the address of SPI  uint8_t *data  - the received data, it is a character array  uint8_t len  - the length of the received data   In  ReSpeaker Arduino Library , we have an example  of SPI bridge:  void spi_event(uint8_t addr, uint8_t *data, uint8_t len)\n{\n  if (0 == addr) {\n    if (0 == data[0]) {   // all off\n      color = 0x000000;\n      pixels_state = 0;\n    } else if (1 == data[0]) {  // specific color\n      color = Pixels::RGB(data[1], data[2], data[3]);\n      pixels_state = 0;\n    } else if (2 == data[0] || 7 == data[0]) {    // listening mode, all green\n      color = Pixels::RGB(0, 0x40, 0);\n      pixels_state = 0;\n    } else if (3 == data[0]) {    // waiting mode\n      pixels_state = 1;\n    }  else if (4 == data[0]) {   // speaking mode\n      pixels_state = 2;\n    } else if (5 == data[0]) {    // volume mode\n      pixels_state = 3;\n      volume = data[3];\n      volume_changed_time = 0;\n    }\n  } else if (0xA0 == addr) {       // spectrum data\n    pixels_state = -1;\n    for (int i = 0; i   PIXELS_NUM; i++) {\n      // Serial.print(data[i]);\n      // Serial.print(' ');\n      pixels- set_color(i, change_brightness(b2r(i * 255 / (PIXELS_NUM - 1)), data[i]));\n      // pixels- set_color(i, change_brightness(b2r(data[i]), data[i]));\n    }\n    pixels- update();\n    // Serial.print( \\r\\n );\n  }\n}  Note: Please stop mopidy service on OpenWrt before using SPI bridge  /etc/init.d/mopidy stop  On OpenWrt side, there is a spi instantiation in \"respeaker\" package. Import it from \"respeaker\", and send data with   spi.write(self, data=None, address=None)  method.    def write(self, data=None, address=None):\n            if address is not None:\n                data = bytearray([0xA5, address   0xFF, len(data)   0xFF]) + data + bytearray([crc8(data)])\n                response = self._write(data)[3:-1]\n            else:\n                response = self._write(data)\n\n            return response   data  - the data sent to Arduino, it should be a bytearray  address  - the address of SPI   from respeaker import spi\n//send data [1, 0, 0, 50] to Arduino, which will make the leds turn blue.\nspi.write(data = bytearray([1, 0, 0, 50]), address = 0x00)", 
            "title": "SPI bridge"
        }, 
        {
            "location": "/ProgrammingGuide/#uart", 
            "text": "There are 2 serial ports available in ATmage32U4: \"serial\" and \"serial1\". The \"serial\" is sumilated by the USB port shared with MT7688 and the \"serial1\" (on TXD1 and RXD1) is connected to MT7688 (on UART_RXD2 and UART_TXD2). They have been set their baudrate to 57600 bps in respeaker.begin().  void ReSpeaker::begin(int touch, int pixels, int spi)\n{\n    Serial.begin(57600);\n    Serial1.begin(57600);\n    ......\n}  ReSpeaker Arduino Library  provides 2 menthods to send Linux command to Openwrt Shell directly.  void ReSpeaker::play(const char *name)\n{\n    Serial1.print( play  );\n    Serial1.print(name);\n    Serial1.print('\\n');\n}  Send a play-music command to OpenWrt shell   const char *name  - the absolute path or SD card path of your music file   void ReSpeaker::exec(const char *cmd)\n{\n    Serial1.print(cmd);\n    Serial1.print('\\n');\n}  Send a Linux shell command line to OpenWrt Shell   const char *cmd  - Linux shell command line", 
            "title": "UART"
        }, 
        {
            "location": "/ProgrammingGuide/#fruit-piano", 
            "text": "Rather than the on board MT7688 Wi-FI module which runs the Linux based OpenWrt, ReSpeaker is also powered by the ATmega32u4 chip and it\u2019s absolutely Arduino compatible, which means, we can use ReSpeaker as a powerful Arduino board and do many \u2018Arduino\u2019 things. It\u2019s for learning, it\u2019s for practicing, and it\u2019s for fun.  For example, you can program it with Arduino IDE to have a special DIY piano that is built on 8 cherry tomatoes connecting to the 8 touch sensors of ReSpeaker.", 
            "title": "Fruit piano"
        }, 
        {
            "location": "/ProgrammingGuide/#getting-started_1", 
            "text": "git clone https://github.com/respeaker/piano.git   On ReSpeaker, download the repository   Download  ReSpeaker Arduino Library  in your computer  Upload  piano.ino  to ReSpeaker's Arduino Leonardo (ATmega32U4)  Run  python piano.py  on ReSpeaker's serial console", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ProgrammingGuide/#weather-cloud", 
            "text": "Weather Cloud is an awesome project for ReSpeaker. This cool build turns a ReSpeaker into a Weather Cloud, which is able to show you the whether with vivid light and sounds.  In this project, Openwrt is in charge of getting realtime weather information from the Internet, making voice interaction and audio output, while Arduino is responsible for controlling the colorful RGB LEDs.", 
            "title": "Weather Cloud"
        }, 
        {
            "location": "/ProgrammingGuide/#getting-started_2", 
            "text": "git clone https://github.com/jerryyip/WeatherCloud.git   on ReSpeaker, download the repository   Download  ReSpeaker Arduino Library  in your computer  Upload  pixels_pattern.ino  in ReSpeaker Arduino  Library to ReSpeaker's Arduino   Get OpenWeatherMap appid from  here  and copy it to  appID = \"\"  in  main.py , don't forget to add your city in  city=\"\"  Stop mopidy service on OpenWrt before using SPI bridge /etc/init.d/mopidy stop  Run  python main.py  and say \"ReSpeaker, what is the weather like?\" to ReSpeaker.  For more details about how to make a Weather Could, please click  here .", 
            "title": "Getting started"
        }, 
        {
            "location": "/ReSpeakerArduinoLibrary/", 
            "text": "ReSpeaker Arduino Library\n\n\nReSpeaker Arudino Library\n provides the following features: \n\n\n\n\nSupported capacitive touch sensing\n\n\nImplemented WS2812 RGB LED driver\n\n\nBuilt USB to Serial bridge and SPI bridge between - Arduino (ATmega32U4) and linux based OpenWrt (MT7688)\n\n\n\n\nclass ReSpeaker\n\n\n\n\n\n\nvoid begin(int touch=1, int pixels=1, int spi=1);\n\n\nSetup touch buttons, full color pixels and spi bridge\n\n\n\n\n\n\nParameters:\n\n\ntouch\n - 1-enable touch buttons, 0-disable\n\n\npixeld\n - 1-enable pixels, 0-disable\n\n\nspi\n - 1-enable spi bridge, 0-disable\n\n\n\n\n\n\n```C++\n//Example usage\nvoid setup() {\n  respeaker.begin();\n  }\n\n\n\n\n\n\n\n- **void play(const char \\*name);**\n\n    Play music file on sd card, support wav \n mp3\n\n    - **Parameters:**\n\n        *name* - music file without path\n\n    ```C++\n    //Example usage\n    respeaker.play(\nhi.wav\n);\n\n\n\n\n\n\n\n\nvoid exec(const char *cmd);\n\n\nExecute a shell command\n\n\n\n\n\n\nParameters:\n\n\ncmd\n - command to be executed\n\n\n\n\n\n\n```C++\n//Example usage\nrespeaker.exec(\"python example.py\");\n\n\n\n\n\n\n\n- **uint16\\_t read\\_touch(uint8\\_t id);**\n\n    Charge a touch button's capacity, read the charging time\n\n    - **Parameters:**\n\n        *id* - the id of the touch button\n\n    - **Return:** measurement value\n\n    ```C++\n    //Example usage\n    uint8_t mytouchsensor1 = 1;\n    if (respeaker.read_touch(mytouchsensor1) \n= 100) {\n        //do something here\n      }\n\n\n\n\n\n\n\n\nuint16_t detect_touch();\n\n\nDetect all touch buttons's status\n\n\n\n\nReturn:\n all the touch buttons' status in bit. \n\n\n\n\nC++\n//Example usage\nuint16_t buttonstatus = 0;\nbuttonstatus = respeaker.detect_touch();\nif (buttonstatus == 0xf0) {\n    //do something here\n}\n\n\n\n\n\n\nvoid attach_touch_handler(void (*handler)(uint8_t id, uint8_t event));\n\n\nAttach an interrupt handler which will be called when a touch event happens\n\n\nC++\n//Example usage\nrespeaker.attach_touch_handler(touch_event);  // add touch event handler\n\n\n\n\n\n\nvoid attach_spi_handler(void (*handler)(uint8_t addr, uint8_t *data, uint8_t len));\n     \n\n\nAttach an interrupt handler which will be called when a spi packet is received\n\n\nC++\n//Example usage\nrespeaker.attach_spi_handler(spi_event);\n\n\n\n\n\n\nvoid attach_spi_raw_handler(void (*handler)(uint8_t data));\n \n\n\nAttach an interrupt handler which will be called when a single byte is received from spi\n\n\nC++\n//Example usage\nrespeaker.attach_spi_raw_handler(spi_event);\n\n\n\n\n\n\nPixels \npixels();\n\n\nGet the Pixels reference of the 12 pixels on respeaker\n\n\n\n\nReturn:\n Pixels reference \n\n\n\n\nC++\n//Example usage\nPixels *pixels;\npixels = \nrespeaker.pixels();\n\n\n\n\n\n\nvoid Pixels::set_color(uint32_t rgb);\n\n\nSet color of all pixels(12)\n\n\n\n\n\n\nParameters:\n\n\nrgb\n - hex color codes, for example, 0xff0000 means red and 0xffff00 means yellow\n\n\n\n\n\n\nC++\n//Example usage\npixels-\nset_color(Pixels::RGB(0xff, 0, 0x7f));\npixels-\nupdate();\n\n\n\n\n\n\nvoid Pixels::set_color(uint16_t index, uint32_t rgb);\n\n\nSet color of one pixel\n\n\n\n\n\n\nParameters:\n\n\nindex\n - the index of pixel\n\n\nrgb\n - hex color codes, for example, 0xff0000 means red and 0xffff00 means yellow\n\n\n\n\n\n\nC++\n//Example usage\nfor (int i = 0; i \n PIXELS_NUM; i++) {\n    pixels-\nset_color(i, Pixels::RGB(0, 0, i * 255 / (PIXELS_NUM - 1)));\n  }\npixels-\nupdate();\n\n\n\n\n\n\nvoid Pixels::set_color(uint16_t index, uint8_t r, uint8_t g, uint8_t b);\n\n\nSet color of one pixel\n\n\n\n\n\n\nParameters:\n\n\nindex\n - the index of pixel\n\n\nr\n - color codes of red, from 0 to 255 or 0x00 to 0xff\n\n\ng\n - color codes of green, from 0 to 255 or 0x00 to 0xff\n\n\nb\n - color codes of blue, from 0 to 255 or 0x00 to 0xff\n\n\n\n\n\n\nC++\n//Example usage\nfor (int i = 0; i \n PIXELS_NUM; i++) {\n    pixels-\nset_color(i, 0, 0, i * 255 / (PIXELS_NUM - 1));\n  }\npixels-\nupdate();\n\n\n\n\n\n\nvoid Pixels::update();\n\n\nUpdate color code to all pixels and light them up\n\n\n\n\n\n\nvoid Pixels::clear();\n\n\nLeave all the pixels off\n\n\nC++\n//Example usage\npixels-\nclear();\n\n\n\n\n\n\nvoid Pixels::blink(uint32_t px_value, uint8_t time);\n\n\nSet all the pixels blink\n\n\n\n\n\n\nParameters:\n\n\npx_value\n - hex rgb color codes\n\n\ntime\n -    delay time \n\n\n\n\n\n\nC++\n//Example usage\npixels-\nblink(0xff00ff, 500);\n\n\n\n\n\n\nvoid Pixels::blink(uint32_t px_value, uint8_t time, uint16_t index);\n\n\nSet one pixel blink\n\n\n\n\n\n\nParameters:\n\n\npx_value\n - hex rgb color codes\n\n\ntime\n -    delay time \n\n\nindex\n - the index of pixel\n\n\n\n\n\n\nC++\n//Example usage\nfor (int i = 0; i \n PIXELS_NUM; i++) {\n    pixels-\nblink(0xff00ff, 500, i);\n  }", 
            "title": "ReSpeaker Arduino Library"
        }, 
        {
            "location": "/ReSpeakerArduinoLibrary/#respeaker-arduino-library", 
            "text": "ReSpeaker Arudino Library  provides the following features:    Supported capacitive touch sensing  Implemented WS2812 RGB LED driver  Built USB to Serial bridge and SPI bridge between - Arduino (ATmega32U4) and linux based OpenWrt (MT7688)", 
            "title": "ReSpeaker Arduino Library"
        }, 
        {
            "location": "/ReSpeakerArduinoLibrary/#class-respeaker", 
            "text": "void begin(int touch=1, int pixels=1, int spi=1);  Setup touch buttons, full color pixels and spi bridge    Parameters:  touch  - 1-enable touch buttons, 0-disable  pixeld  - 1-enable pixels, 0-disable  spi  - 1-enable spi bridge, 0-disable    ```C++\n//Example usage\nvoid setup() {\n  respeaker.begin();\n  }    \n- **void play(const char \\*name);**\n\n    Play music file on sd card, support wav   mp3\n\n    - **Parameters:**\n\n        *name* - music file without path\n\n    ```C++\n    //Example usage\n    respeaker.play( hi.wav );    void exec(const char *cmd);  Execute a shell command    Parameters:  cmd  - command to be executed    ```C++\n//Example usage\nrespeaker.exec(\"python example.py\");    \n- **uint16\\_t read\\_touch(uint8\\_t id);**\n\n    Charge a touch button's capacity, read the charging time\n\n    - **Parameters:**\n\n        *id* - the id of the touch button\n\n    - **Return:** measurement value\n\n    ```C++\n    //Example usage\n    uint8_t mytouchsensor1 = 1;\n    if (respeaker.read_touch(mytouchsensor1)  = 100) {\n        //do something here\n      }    uint16_t detect_touch();  Detect all touch buttons's status   Return:  all the touch buttons' status in bit.    C++\n//Example usage\nuint16_t buttonstatus = 0;\nbuttonstatus = respeaker.detect_touch();\nif (buttonstatus == 0xf0) {\n    //do something here\n}    void attach_touch_handler(void (*handler)(uint8_t id, uint8_t event));  Attach an interrupt handler which will be called when a touch event happens  C++\n//Example usage\nrespeaker.attach_touch_handler(touch_event);  // add touch event handler    void attach_spi_handler(void (*handler)(uint8_t addr, uint8_t *data, uint8_t len));        Attach an interrupt handler which will be called when a spi packet is received  C++\n//Example usage\nrespeaker.attach_spi_handler(spi_event);    void attach_spi_raw_handler(void (*handler)(uint8_t data));    Attach an interrupt handler which will be called when a single byte is received from spi  C++\n//Example usage\nrespeaker.attach_spi_raw_handler(spi_event);    Pixels  pixels();  Get the Pixels reference of the 12 pixels on respeaker   Return:  Pixels reference    C++\n//Example usage\nPixels *pixels;\npixels =  respeaker.pixels();    void Pixels::set_color(uint32_t rgb);  Set color of all pixels(12)    Parameters:  rgb  - hex color codes, for example, 0xff0000 means red and 0xffff00 means yellow    C++\n//Example usage\npixels- set_color(Pixels::RGB(0xff, 0, 0x7f));\npixels- update();    void Pixels::set_color(uint16_t index, uint32_t rgb);  Set color of one pixel    Parameters:  index  - the index of pixel  rgb  - hex color codes, for example, 0xff0000 means red and 0xffff00 means yellow    C++\n//Example usage\nfor (int i = 0; i   PIXELS_NUM; i++) {\n    pixels- set_color(i, Pixels::RGB(0, 0, i * 255 / (PIXELS_NUM - 1)));\n  }\npixels- update();    void Pixels::set_color(uint16_t index, uint8_t r, uint8_t g, uint8_t b);  Set color of one pixel    Parameters:  index  - the index of pixel  r  - color codes of red, from 0 to 255 or 0x00 to 0xff  g  - color codes of green, from 0 to 255 or 0x00 to 0xff  b  - color codes of blue, from 0 to 255 or 0x00 to 0xff    C++\n//Example usage\nfor (int i = 0; i   PIXELS_NUM; i++) {\n    pixels- set_color(i, 0, 0, i * 255 / (PIXELS_NUM - 1));\n  }\npixels- update();    void Pixels::update();  Update color code to all pixels and light them up    void Pixels::clear();  Leave all the pixels off  C++\n//Example usage\npixels- clear();    void Pixels::blink(uint32_t px_value, uint8_t time);  Set all the pixels blink    Parameters:  px_value  - hex rgb color codes  time  -    delay time     C++\n//Example usage\npixels- blink(0xff00ff, 500);    void Pixels::blink(uint32_t px_value, uint8_t time, uint16_t index);  Set one pixel blink    Parameters:  px_value  - hex rgb color codes  time  -    delay time   index  - the index of pixel    C++\n//Example usage\nfor (int i = 0; i   PIXELS_NUM; i++) {\n    pixels- blink(0xff00ff, 500, i);\n  }", 
            "title": "class ReSpeaker"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/", 
            "text": "ReSpeaker Python API\n\n\nReSpeaker Python Library\n is an open source python library to provide functions of voice interaction for ReSpeaker.\n\n\nclass BingSpeechAPI\n\n\nProvides methods to:\n\n\n\n\nInitialize BingSpeechAPI\n\n\nApply Bing Speech API access token\n\n\nRealize speech to text and text to speech\n\n\n\n\nGenerate the WAV header and the WAV file contents\n\n\n\n\n\n\ndef __init__(self, key):\n\n\nInitialize BingSpeechAPI.\n\n\n```python\n\n\nExample usage\n\n\nBING_KEY = ''\nbing = BingSpeechAPI(key=BING_KEY)\n\n\n\n\n\n\n\n- **def recognize(self, audio\\_data, language=\nen-US\n, show_all=False):**\n\n    Translate the audio data to text by sending it to Bing Speech API.\n\n    - **Parameters:**\n\n        *audio\\_data* - the audio frames\n\n        *language* - the language of the audio data translating into, defaults to \nen-US\n\n\n        *show\\_all* - whether the entire JSON should be returned, defaults to False\n\n    - **Return:** a JSON containing the hander and lexical\n\n    - **Raise RequestError:** if recognition connection failed\n\n    ```python\n    #Example usage\n\n    try:\n        text = bing.recognize(data)\n        if text:\n            print('Recognized %s' % text)\n    except Exception as e:\n        print(e.message)\n\n\n\n\n\n\n\n\ndef synthesize(self, text, language=\"en-US\", gender=\"Female\"):\n\n\nSynthesize text to audio data by sending it to Bing Speech API.\n\n\n\n\n\n\nParameters:\n\n\ntext\n - an instance of the String object.\n\n\nlanguage\n - the language of the text, supported languages are listed among \nself.locales\n\n\ngender\n - the text to speech voice \n\n\n\n\n\n\nReturn:\n raw audio data\n\n\n\n\n\n\nRaise LocaleError:\n if \nlanguage\n not in \nself.locales\n\n\n\n\n\n\n```python\n\n\nExample usage\n\n\nif spoken_text:\n    audio = bing.synthesize(spoken_text)\n    player.play_raw(audio)\n\n\n\n\n\n\n\n- **def authenticate(self):**\n\n    Apply access token from Bing Speech API. Every call to the Speech API requires a JSON Web Token (JWT) access token and the token has a expire time of 10 minutes.\n\n    It is called by **self.recognize()** and **self.synthesize()**.\n    - **Parameters:**\n\n        *self.access\\_token* - access token from Bing Speech API \n\n    - **Raise RequestError:** if recognition connection failed\n\n\n- **@staticmethod**\n\n    **def to\\_wav(raw\\_data):**\n\n    Generate the WAV file contents with raw audio data.\n\n    It is called by **self.recognize()**.\n\n    - **Parameters:**\n\n        *raw\\_data* - raw audio data\n\n    - **Return:** WAV data\n\n\n- **@staticmethod**\n\n    **def get\\_wav\\_header():**\n\n    Generate the WAV header. \n\n    It is called by **self.recognize()**.\n\n    - **Return:** WAV header\n\n\n##class Player\n\nBased on [PyAudio](https://people.csail.mit.edu/hubert/pyaudio/docs/) and [wave](https://docs.python.org/2/library/wave.html), provides methods to:\n\n1. Initialize Player\n2. Play wav file and raw audio data file.\n\n- **def \\_\\_init\\_\\_(self, pa):**\n\n    Initialize Player.\n\n    - **Parameters:**\n\n        *pa* - PyAudio instance\n\n    ```python\n    #Example usage\n    mic = Microphone()\n   player = Player(mic.pyaudio_instance)\n\n\n\n\n\n\n\n\ndef play(self, wav_file, block=True):\n\n\nPlay wav audio file.\n\n\n\n\n\n\nParameters:\n\n\nwav_file\n - wav file\n\n\nblock\n - whether wait for playing audio data in buffer, defaults to True\n\n\n\n\n\n\n```python\n\n\nExample usage\n\n\nscript_dir = os.path.dirname(os.path.realpath(\nfile\n))\nhi = os.path.join(script_dir, 'audio/hi.wav')\nplayer.play(hi)\n\n\n\n\n\n\n\n\n- **def play\\_raw(self, raw\\_data, rate=16000, channels=1, width=2, block=True):**\n\n    Play raw audio file.\n\n    - **Parameters:**\n\n        *raw\\_data* - raw audio data file\n\n        *block* - whether wait for playing audio data in buffer, defaults to True\n\n    ```python\n    #Example usage  \n    if spoken_text:\n        audio = bing.synthesize(spoken_text)\n        player.play_raw(audio)      \n\n\n\n\nclass Microphone\n\n\nProvides methods to:\n\n\n\n\nInitialize Microphone\n\n\nTranslate raw audio data into text\n\n\nWake up ReSpeaker with keyword\n\n\n\n\nListen and record the speech\n\n\n\n\n\n\ndef __init__(self, pyaudio_instance=None, quit_event=None):\n\n\nInitialize Microphone.\n\n\n\n\n\n\nParameters:\n\n\npyaudio_instance\n - PyAudio instance, defaults to None \n\n\nquit_event\n - if quit_event is set, defaults to None\n\n\n\n\n\n\n```python\n\n\nExample usage\n\n\nmic = Microphone()  \n\n\n\n\n\n\n\n- **def recognize(self, data):**\n\n    Translate raw audio data into text with [PocketSphinx](https://github.com/cmusphinx/pocketsphinx).\n\n    - **Parameters:**\n\n        *data* - raw audio data\n\n    - **Return:** string\n\n    ```python\n    #Example usage  \n    data = mic.listen()\n    text = mic.recognize(data)\n    if text:\n        time.sleep(1)\n        print('Recognized %s' % text) \n\n\n\n\n\n\n\n\ndef detect(self, keyword=None):\n\n\ndef wakeup(self, keyword=None):\n\n\ndetect\n and \nwakeup\n are used to wake up ReSpeaker when the keyword is detected.\n\n\n\n\n\n\nParameters:\n\n\nkeyword\n - the keyword to wake up ReSpeaker \n\n\n\n\n\n\nReturn:\n if the keyword is detected, return the keyword; if not, return None.\n\n\n\n\n\n\n```python\n\n\nExample usage\n\n\nif mic.wakeup('respeaker'):\n    print('wake up')\n    data = mic.listen()\n    text = mic.recognize(data)\n    if text:\n        time.sleep(1)\n        print('Recognized %s' % text) \n\n\n\n\n\n\n\n\n- **def listen(self, duration=9, timeout=3):**\n\n    Listen and record the speech.\n\n    - **Parameters:**\n\n        *duration* - listen the speech for the given number of seconds, defaults to 9 seconds\n\n        *timeout* - stop listening when don't detect any speeches for the given number of seconds, defaults to 3 seconds\n\n    - **Return:** raw audio data\n\n    ```python\n    #Example usage  \n    if mic.wakeup('respeaker'):\n        print('wake up')\n        data = mic.listen()\n        text = mic.recognize(data)\n        if text:\n            time.sleep(1)\n            print('Recognized %s' % text) \n    ```\n\n- **def record(self, file_name, seconds=1800):**\n\n    Record the speech and save the audio file.\n\n    - **Parameters:**\n\n        *file_name* - file name of the saved audio file\n\n        *seconds* - recording seconds, defaults to 1800 seconds \n\n\n- **def start(self):**\n\n    Start processing the audio stream.\n\n- **def stop(self):**\n\n    Pause playing/recording.\n\n- **def close(self):**\n\n    Terminate the stream.\n\n- **def task(quit_event):**\n\n    An example of a wakeup and recognize task.\n\n    ```python\n    #Example usage  \n    q = Event()\n    t = Thread(target=task, args=(q,))\n    t.start()\n    while True:\n        try:\n            time.sleep(1)\n        except KeyboardInterrupt:\n        print('Quit')\n        q.set()\n            break\n    t.join()\n    ```\n\n\n##class SPI\n\nProvides methods to:\n\n1. Initialize SPI\n2. Send data to Arduino via SPI\n\n- **def \\_\\_init\\_\\_(self, sck=15, mosi=17, miso=16, cs=14):**\n\n    Initialize SPI. Note that class SPI has been instantiated in spi.py, so don't have to initialize it again.\n\n    ```python\n    #Example usage\n    from respeaker import spi\n    spi.write(data = bytearray([1, 0, 0, 50]), address = 0x00)\n\n\n\n\n\n\n\n\ndef write(self, data=None, address=None):\n\n\nSend data to Arduino. Click this \nData exchange between Arduino and OpenWrt\n for more introduction.\n\n\n\n\n\n\nParameters:\n\n\ndata\n - the data sent to Arduino, it should be a bytearray\n\n\naddress\n - the address of SPI\n\n\n\n\n\n\n```python\nfrom respeaker import spi\n\n\nsend data [1, 0, 0, 50] to Arduino, which will make the leds turn blue.\n\n\nspi.write(data = bytearray([1, 0, 0, 50]), address = 0x00)\n```\n\n\n\n\n\n\nclass PixelRing\n\n\nDepends on \nclass SPI\n, provides methods to:\n\n\n\n\nInitialize PixelRing\n\n\nSet pixel leds to \noff``listen``wait\n modes\n\n\n\n\nSet specific color to pixel leds \n\n\n\n\n\n\ndef __init__(self):\n\n\nInitialize PixelRing. Note that class PixelRing has been instantiated in pixel_ring.py, so you don't need to initialize it again.\n\n\n```python\n\n\nExample usage\n\n\nfrom respeaker import pixel_ring\n\n\npixel_ring.listen()\ntime.sleep(3)\npixel_ring.wait()\ntime.sleep(3)\nfor level in range(2, 8):\n    pixel_ring.speak(level, 0)\n    time.sleep(1)\npixel_ring.set_volume(4)\ntime.sleep(3)\n\n\n\n\n\n\n\n- **def off(self):**\n\n    Set pixel leds all off.\n\n    ```python\n    #Example usage\n    pixel_ring.off()\n\n\n\n\n\n\n\n\ndef listen(self, direction=None):\n\n\nSet pixel leds to \nlisten\n mode, which makes leds all green.\n\n\n\n\n\n\nParameters:\n\n\ndirection\n - when direction is None, send \nself.write(0, [7, 0, 0, 0])\n and while direction is not None, send \nself.write(0, [2, 0, direction \n 0xFF, (direction \n 8) \n 0xFF])\n\n\n\n\n\n\n```python\n\n\nExample usage\n\n\npixel_ring.listen()\n\n\n\n\n\n\n\n- **def wait(self):**\n\n    Set pixel leds to `wait` mode, which makes three leds green and running in circle.\n\n    ```python\n    #Example usage\n    pixel_ring.wait()\n\n\n\n\n\n\n\n\ndef set_color(self, rgb=None, r=0, g=0, b=0):\n\n\nSet specific color to all pixel leds.\n\n\n\n\n\n\nParameters:\n\n\nrgb\n - hex color codes, for example, 0xff0000 means red and 0xffff00 means yellow\n\n\nr\n - color codes of red, from 0 to 255 or 0x00 to 0xff\n\n\ng\n - color codes of green, from 0 to 255 or 0x00 to 0xff\n\n\nb\n - color codes of blue, from 0 to 255 or 0x00 to 0xff\n\n\n\n\n\n\n```python\n\n\nExample usage\n\n\npixel_ring.set_color(rgb=0x505000)\ntime.sleep(3)\npixel_ring.set_color(r=150, g=100, b=20)\n```", 
            "title": "ReSpeaker Python API"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#respeaker-python-api", 
            "text": "ReSpeaker Python Library  is an open source python library to provide functions of voice interaction for ReSpeaker.", 
            "title": "ReSpeaker Python API"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#class-bingspeechapi", 
            "text": "Provides methods to:   Initialize BingSpeechAPI  Apply Bing Speech API access token  Realize speech to text and text to speech   Generate the WAV header and the WAV file contents    def __init__(self, key):  Initialize BingSpeechAPI.  ```python", 
            "title": "class BingSpeechAPI"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#example-usage", 
            "text": "BING_KEY = ''\nbing = BingSpeechAPI(key=BING_KEY)    \n- **def recognize(self, audio\\_data, language= en-US , show_all=False):**\n\n    Translate the audio data to text by sending it to Bing Speech API.\n\n    - **Parameters:**\n\n        *audio\\_data* - the audio frames\n\n        *language* - the language of the audio data translating into, defaults to  en-US \n\n        *show\\_all* - whether the entire JSON should be returned, defaults to False\n\n    - **Return:** a JSON containing the hander and lexical\n\n    - **Raise RequestError:** if recognition connection failed\n\n    ```python\n    #Example usage\n\n    try:\n        text = bing.recognize(data)\n        if text:\n            print('Recognized %s' % text)\n    except Exception as e:\n        print(e.message)    def synthesize(self, text, language=\"en-US\", gender=\"Female\"):  Synthesize text to audio data by sending it to Bing Speech API.    Parameters:  text  - an instance of the String object.  language  - the language of the text, supported languages are listed among  self.locales  gender  - the text to speech voice     Return:  raw audio data    Raise LocaleError:  if  language  not in  self.locales    ```python", 
            "title": "Example usage"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#example-usage_1", 
            "text": "if spoken_text:\n    audio = bing.synthesize(spoken_text)\n    player.play_raw(audio)    \n- **def authenticate(self):**\n\n    Apply access token from Bing Speech API. Every call to the Speech API requires a JSON Web Token (JWT) access token and the token has a expire time of 10 minutes.\n\n    It is called by **self.recognize()** and **self.synthesize()**.\n    - **Parameters:**\n\n        *self.access\\_token* - access token from Bing Speech API \n\n    - **Raise RequestError:** if recognition connection failed\n\n\n- **@staticmethod**\n\n    **def to\\_wav(raw\\_data):**\n\n    Generate the WAV file contents with raw audio data.\n\n    It is called by **self.recognize()**.\n\n    - **Parameters:**\n\n        *raw\\_data* - raw audio data\n\n    - **Return:** WAV data\n\n\n- **@staticmethod**\n\n    **def get\\_wav\\_header():**\n\n    Generate the WAV header. \n\n    It is called by **self.recognize()**.\n\n    - **Return:** WAV header\n\n\n##class Player\n\nBased on [PyAudio](https://people.csail.mit.edu/hubert/pyaudio/docs/) and [wave](https://docs.python.org/2/library/wave.html), provides methods to:\n\n1. Initialize Player\n2. Play wav file and raw audio data file.\n\n- **def \\_\\_init\\_\\_(self, pa):**\n\n    Initialize Player.\n\n    - **Parameters:**\n\n        *pa* - PyAudio instance\n\n    ```python\n    #Example usage\n    mic = Microphone()\n   player = Player(mic.pyaudio_instance)    def play(self, wav_file, block=True):  Play wav audio file.    Parameters:  wav_file  - wav file  block  - whether wait for playing audio data in buffer, defaults to True    ```python", 
            "title": "Example usage"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#example-usage_2", 
            "text": "script_dir = os.path.dirname(os.path.realpath( file ))\nhi = os.path.join(script_dir, 'audio/hi.wav')\nplayer.play(hi)    \n\n- **def play\\_raw(self, raw\\_data, rate=16000, channels=1, width=2, block=True):**\n\n    Play raw audio file.\n\n    - **Parameters:**\n\n        *raw\\_data* - raw audio data file\n\n        *block* - whether wait for playing audio data in buffer, defaults to True\n\n    ```python\n    #Example usage  \n    if spoken_text:\n        audio = bing.synthesize(spoken_text)\n        player.play_raw(audio)", 
            "title": "Example usage"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#class-microphone", 
            "text": "Provides methods to:   Initialize Microphone  Translate raw audio data into text  Wake up ReSpeaker with keyword   Listen and record the speech    def __init__(self, pyaudio_instance=None, quit_event=None):  Initialize Microphone.    Parameters:  pyaudio_instance  - PyAudio instance, defaults to None   quit_event  - if quit_event is set, defaults to None    ```python", 
            "title": "class Microphone"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#example-usage_3", 
            "text": "mic = Microphone()      \n- **def recognize(self, data):**\n\n    Translate raw audio data into text with [PocketSphinx](https://github.com/cmusphinx/pocketsphinx).\n\n    - **Parameters:**\n\n        *data* - raw audio data\n\n    - **Return:** string\n\n    ```python\n    #Example usage  \n    data = mic.listen()\n    text = mic.recognize(data)\n    if text:\n        time.sleep(1)\n        print('Recognized %s' % text)     def detect(self, keyword=None):  def wakeup(self, keyword=None):  detect  and  wakeup  are used to wake up ReSpeaker when the keyword is detected.    Parameters:  keyword  - the keyword to wake up ReSpeaker     Return:  if the keyword is detected, return the keyword; if not, return None.    ```python", 
            "title": "Example usage"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#example-usage_4", 
            "text": "if mic.wakeup('respeaker'):\n    print('wake up')\n    data = mic.listen()\n    text = mic.recognize(data)\n    if text:\n        time.sleep(1)\n        print('Recognized %s' % text)     \n\n- **def listen(self, duration=9, timeout=3):**\n\n    Listen and record the speech.\n\n    - **Parameters:**\n\n        *duration* - listen the speech for the given number of seconds, defaults to 9 seconds\n\n        *timeout* - stop listening when don't detect any speeches for the given number of seconds, defaults to 3 seconds\n\n    - **Return:** raw audio data\n\n    ```python\n    #Example usage  \n    if mic.wakeup('respeaker'):\n        print('wake up')\n        data = mic.listen()\n        text = mic.recognize(data)\n        if text:\n            time.sleep(1)\n            print('Recognized %s' % text) \n    ```\n\n- **def record(self, file_name, seconds=1800):**\n\n    Record the speech and save the audio file.\n\n    - **Parameters:**\n\n        *file_name* - file name of the saved audio file\n\n        *seconds* - recording seconds, defaults to 1800 seconds \n\n\n- **def start(self):**\n\n    Start processing the audio stream.\n\n- **def stop(self):**\n\n    Pause playing/recording.\n\n- **def close(self):**\n\n    Terminate the stream.\n\n- **def task(quit_event):**\n\n    An example of a wakeup and recognize task.\n\n    ```python\n    #Example usage  \n    q = Event()\n    t = Thread(target=task, args=(q,))\n    t.start()\n    while True:\n        try:\n            time.sleep(1)\n        except KeyboardInterrupt:\n        print('Quit')\n        q.set()\n            break\n    t.join()\n    ```\n\n\n##class SPI\n\nProvides methods to:\n\n1. Initialize SPI\n2. Send data to Arduino via SPI\n\n- **def \\_\\_init\\_\\_(self, sck=15, mosi=17, miso=16, cs=14):**\n\n    Initialize SPI. Note that class SPI has been instantiated in spi.py, so don't have to initialize it again.\n\n    ```python\n    #Example usage\n    from respeaker import spi\n    spi.write(data = bytearray([1, 0, 0, 50]), address = 0x00)    def write(self, data=None, address=None):  Send data to Arduino. Click this  Data exchange between Arduino and OpenWrt  for more introduction.    Parameters:  data  - the data sent to Arduino, it should be a bytearray  address  - the address of SPI    ```python\nfrom respeaker import spi", 
            "title": "Example usage"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#send-data-1-0-0-50-to-arduino-which-will-make-the-leds-turn-blue", 
            "text": "spi.write(data = bytearray([1, 0, 0, 50]), address = 0x00)\n```", 
            "title": "send data [1, 0, 0, 50] to Arduino, which will make the leds turn blue."
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#class-pixelring", 
            "text": "Depends on  class SPI , provides methods to:   Initialize PixelRing  Set pixel leds to  off``listen``wait  modes   Set specific color to pixel leds     def __init__(self):  Initialize PixelRing. Note that class PixelRing has been instantiated in pixel_ring.py, so you don't need to initialize it again.  ```python", 
            "title": "class PixelRing"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#example-usage_5", 
            "text": "from respeaker import pixel_ring  pixel_ring.listen()\ntime.sleep(3)\npixel_ring.wait()\ntime.sleep(3)\nfor level in range(2, 8):\n    pixel_ring.speak(level, 0)\n    time.sleep(1)\npixel_ring.set_volume(4)\ntime.sleep(3)    \n- **def off(self):**\n\n    Set pixel leds all off.\n\n    ```python\n    #Example usage\n    pixel_ring.off()    def listen(self, direction=None):  Set pixel leds to  listen  mode, which makes leds all green.    Parameters:  direction  - when direction is None, send  self.write(0, [7, 0, 0, 0])  and while direction is not None, send  self.write(0, [2, 0, direction   0xFF, (direction   8)   0xFF])    ```python", 
            "title": "Example usage"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#example-usage_6", 
            "text": "pixel_ring.listen()    \n- **def wait(self):**\n\n    Set pixel leds to `wait` mode, which makes three leds green and running in circle.\n\n    ```python\n    #Example usage\n    pixel_ring.wait()    def set_color(self, rgb=None, r=0, g=0, b=0):  Set specific color to all pixel leds.    Parameters:  rgb  - hex color codes, for example, 0xff0000 means red and 0xffff00 means yellow  r  - color codes of red, from 0 to 255 or 0x00 to 0xff  g  - color codes of green, from 0 to 255 or 0x00 to 0xff  b  - color codes of blue, from 0 to 255 or 0x00 to 0xff    ```python", 
            "title": "Example usage"
        }, 
        {
            "location": "/ReSpeakerPythonAPI/#example-usage_7", 
            "text": "pixel_ring.set_color(rgb=0x505000)\ntime.sleep(3)\npixel_ring.set_color(r=150, g=100, b=20)\n```", 
            "title": "Example usage"
        }
    ]
}